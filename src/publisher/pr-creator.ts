import { Octokit } from "@octokit/rest";
import type { TriageResult, PRDetails, FailureContext } from "../collector/types.js";

/**
 * Create a pull request with the fix
 */
export async function createPullRequest(
  octokit: Octokit,
  owner: string,
  repo: string,
  baseBranch: string,
  headBranch: string,
  result: TriageResult,
  context: FailureContext,
  titleTemplate: string
): Promise<PRDetails> {
  const title = formatTitle(titleTemplate, result, context);
  const body = formatPRBody(result, context, owner, repo);

  const { data: pr } = await octokit.rest.pulls.create({
    owner,
    repo,
    title,
    body,
    head: headBranch,
    base: baseBranch
  });

  // Add labels
  const labels = ["greenlit", "auto-fix"];
  if (result.confidence) {
    labels.push(`confidence-${result.confidence}`);
  }

  await octokit.rest.issues.addLabels({
    owner,
    repo,
    issue_number: pr.number,
    labels
  });

  console.log(`   PR created: ${pr.html_url}`);

  return {
    prNumber: pr.number,
    prUrl: pr.html_url,
    branchName: headBranch
  };
}

/**
 * Post a comment on the original PR/commit
 */
export async function postComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  context: FailureContext,
  result: TriageResult,
  prDetails?: PRDetails
): Promise<void> {
  const body = formatCommentBody(result, context, prDetails);

  // Try to find associated PR
  const { data: prs } = await octokit.rest.repos.listPullRequestsAssociatedWithCommit({
    owner,
    repo,
    commit_sha: context.sha
  });

  if (prs.length > 0) {
    // Post on the PR
    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: prs[0].number,
      body
    });
    console.log(`   Comment posted on PR #${prs[0].number}`);
  } else {
    // Post on the commit
    await octokit.rest.repos.createCommitComment({
      owner,
      repo,
      commit_sha: context.sha,
      body
    });
    console.log(`   Comment posted on commit ${context.sha.substring(0, 7)}`);
  }
}

/**
 * Format PR title from template
 */
function formatTitle(template: string, result: TriageResult, context: FailureContext): string {
  // Extract a short summary from the fix
  const summary = result.rootCause.split("\n")[0].slice(0, 50);

  return template
    .replace("{failure_type}", context.failureType)
    .replace("{summary}", summary)
    .replace("{branch}", context.branch);
}

/**
 * Format full PR body with RCA
 */
function formatPRBody(
  result: TriageResult,
  context: FailureContext,
  owner: string,
  repo: string
): string {
  const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;

  return `## ü§ñ Greenlit Auto-Fix

This PR was automatically generated by **Greenlit** to fix a CI failure.

| | |
|---|---|
| **Failed Run** | [#${context.runId}](${runUrl}) |
| **Branch** | \`${context.branch}\` |
| **Commit** | \`${context.sha.substring(0, 7)}\` |
| **Failure Type** | ${context.failureType} |
| **Confidence** | ${result.confidence?.toUpperCase() || "N/A"} |

---

## üìã Root Cause Analysis

### Error Signature
\`\`\`
${context.errorSignature}
\`\`\`

### Root Cause
${result.rootCause}

---

## üîß Fix Applied

${result.fixSummary}

---

## ‚úÖ Verification

The fix was verified by re-running the failing command.

<details>
<summary>Verification Output</summary>

\`\`\`
${result.verificationLog.slice(-3000)}
\`\`\`

</details>

---

## üìù Changes

<details>
<summary>View Diff</summary>

\`\`\`diff
${result.patchDiff}
\`\`\`

</details>

---

> ‚ö†Ô∏è **Note**: This is an automated fix. Please review carefully before merging.
>
> üîë **Fingerprint**: \`${context.fingerprint}\`
>
> Generated by [Greenlit](https://github.com/Avinier/greenlit)
`;
}

/**
 * Format comment body for non-PR situations
 */
function formatCommentBody(
  result: TriageResult,
  context: FailureContext,
  prDetails?: PRDetails
): string {
  const statusEmoji = result.success ? "‚úÖ" : "‚ùå";
  const statusText = result.success ? "Fix Generated" : "Analysis Complete";

  let body = `## ${statusEmoji} Greenlit: ${statusText}

**Failure Type**: ${context.failureType}
**Routing Decision**: ${result.routingDecision}
**Confidence**: ${result.confidence || "N/A"}

### Error Signature
\`\`\`
${context.errorSignature}
\`\`\`

### Root Cause
${result.rootCause}
`;

  if (result.success && prDetails) {
    body += `
---

### üéâ Fix PR Created

**[PR #${prDetails.prNumber}](${prDetails.prUrl})** - Ready for review

The fix has been verified and a PR has been created automatically.
`;
  } else if (!result.success) {
    body += `
---

### Recommendation

${result.fixSummary}
`;
  }

  body += `
---

<sub>üîë Fingerprint: \`${context.fingerprint}\` | Generated by [Greenlit](https://github.com/Avinier/greenlit)</sub>
`;

  return body;
}

/**
 * Format RCA markdown for standalone output
 */
export function formatRCAMarkdown(result: TriageResult, context: FailureContext): string {
  return `# Greenlit RCA Report

**Repository**: ${context.repo}
**Branch**: ${context.branch}
**Commit**: ${context.sha}
**Run ID**: ${context.runId}
**Generated**: ${new Date().toISOString()}

---

## Summary

**Status**: ${result.success ? "‚úÖ Fixed" : "‚ùå Not Fixed"}
**Failure Type**: ${context.failureType}
**Failure Class**: ${context.failureClass}
**Routing**: ${result.routingDecision}
**Confidence**: ${result.confidence}

---

## Error Signature

\`\`\`
${context.errorSignature}
\`\`\`

---

## Root Cause

${result.rootCause}

---

## Fix Summary

${result.fixSummary}

---

## Patch

\`\`\`diff
${result.patchDiff || "(no changes)"}
\`\`\`

---

## Verification

\`\`\`
${result.verificationLog || "(no verification run)"}
\`\`\`

---

**Fingerprint**: \`${context.fingerprint}\`
`;
}
